// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// This API communicates between the ZeroBound server and its clients
internal struct Client: STCAPIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// PlaidLinkTokenCreate
    ///
    /// - Remark: HTTP `GET /plaid/link/token/create`.
    /// - Remark: Generated from `#/paths//plaid/link/token/create/get(get-plaid-link-token-create)`.
    internal func getPlaidLinkTokenCreate(_ input: Operations.GetPlaidLinkTokenCreate.Input) async throws -> Operations.GetPlaidLinkTokenCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetPlaidLinkTokenCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/plaid/link/token/create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetPlaidLinkTokenCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PlaidLinkToken.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// PlaidLinkTokenUpdate
    ///
    /// - Remark: HTTP `GET /plaid/link/token/update`.
    /// - Remark: Generated from `#/paths//plaid/link/token/update/get(get-plaid-link-token-update)`.
    internal func getPlaidLinkTokenUpdate(_ input: Operations.GetPlaidLinkTokenUpdate.Input) async throws -> Operations.GetPlaidLinkTokenUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetPlaidLinkTokenUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/plaid/link/token/update",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetPlaidLinkTokenUpdate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PlaidLinkToken.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// AccountsGet
    ///
    /// Get accounts from server
    ///
    /// - Remark: HTTP `GET /accounts`.
    /// - Remark: Generated from `#/paths//accounts/get(get-accounts)`.
    internal func getAccounts(_ input: Operations.GetAccounts.Input) async throws -> Operations.GetAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.accountId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetAccounts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Account].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// AccountsPost
    ///
    /// Post new account to server
    ///
    /// - Remark: HTTP `POST /accounts`.
    /// - Remark: Generated from `#/paths//accounts/post(post-accounts)`.
    internal func postAccounts(_ input: Operations.PostAccounts.Input) async throws -> Operations.PostAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PostAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .urlEncodedForm(value):
                    body = try converter.setOptionalRequestBodyAsURLEncodedForm(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/x-www-form-urlencoded"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// AccountsPut
    ///
    /// Update existing account on server
    ///
    /// - Remark: HTTP `PUT /accounts`.
    /// - Remark: Generated from `#/paths//accounts/put(put-accounts)`.
    internal func putAccounts(_ input: Operations.PutAccounts.Input) async throws -> Operations.PutAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PutAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// AccountsDelete
    ///
    /// Delete account from server
    ///
    /// - Remark: HTTP `DELETE /accounts`.
    /// - Remark: Generated from `#/paths//accounts/delete(delete-accounts)`.
    internal func deleteAccounts(_ input: Operations.DeleteAccounts.Input) async throws -> Operations.DeleteAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DeleteAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.accountId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// TransactionsGet
    ///
    /// - Remark: HTTP `GET /transactions`.
    /// - Remark: Generated from `#/paths//transactions/get(get-transactions)`.
    internal func getTransactions(_ input: Operations.GetTransactions.Input) async throws -> Operations.GetTransactions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/transactions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.accountId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetTransactions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Transaction].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// TransactionsPost
    ///
    /// - Remark: HTTP `POST /transactions`.
    /// - Remark: Generated from `#/paths//transactions/post(post-transactions)`.
    internal func postTransactions(_ input: Operations.PostTransactions.Input) async throws -> Operations.PostTransactions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PostTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/transactions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// TransactionsPut
    ///
    /// - Remark: HTTP `PUT /transactions`.
    /// - Remark: Generated from `#/paths//transactions/put(put-transactions)`.
    internal func putTransactions(_ input: Operations.PutTransactions.Input) async throws -> Operations.PutTransactions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PutTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/transactions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "transaction_id",
                    value: input.query.transactionId
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// TransactionsDelete
    ///
    /// - Remark: HTTP `DELETE /transactions`.
    /// - Remark: Generated from `#/paths//transactions/delete(delete-transactions)`.
    internal func deleteTransactions(_ input: Operations.DeleteTransactions.Input) async throws -> Operations.DeleteTransactions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DeleteTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/transactions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "transaction_id",
                    value: input.query.transactionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    return .accepted(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// TransactionsSync
    ///
    /// - Remark: HTTP `GET /transactions/sync`.
    /// - Remark: Generated from `#/paths//transactions/sync/get(get-transactions-sync)`.
    internal func getTransactionsSync(_ input: Operations.GetTransactionsSync.Input) async throws -> Operations.GetTransactionsSync.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetTransactionsSync.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/transactions/sync",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetTransactionsSync.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InlineResponse200.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 204:
                    return .noContent(.init())
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// LiabilitiesGet
    ///
    /// - Remark: HTTP `GET /liabilities`.
    /// - Remark: Generated from `#/paths//liabilities/get(get-liabilities)`.
    internal func getLiabilities(_ input: Operations.GetLiabilities.Input) async throws -> Operations.GetLiabilities.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetLiabilities.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/liabilities",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.accountId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLiabilities.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Liability].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
