// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
extension APIProtocol {
    /// Registers each operation handler with the provided transport.
    /// - Parameters:
    ///   - transport: A transport to which to register the operation handlers.
    ///   - serverURL: A URL used to determine the path prefix for registered
    ///   request handlers.
    ///   - configuration: A set of configuration values for the server.
    ///   - middlewares: A list of middlewares to call before the handler.
    internal func registerHandlers(
        on transport: any ServerTransport,
        serverURL: Foundation.URL = .defaultOpenAPIServerURL,
        configuration: Configuration = .init(),
        middlewares: [any ServerMiddleware] = []
    ) throws {
        let server = UniversalServer(
            serverURL: serverURL,
            handler: self,
            configuration: configuration,
            middlewares: middlewares
        )
        try transport.register(
            {
                try await server.getPlaidLinkTokenCreate(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/plaid/link/token/create")
        )
        try transport.register(
            {
                try await server.getPlaidLinkTokenUpdate(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/plaid/link/token/update")
        )
        try transport.register(
            {
                try await server.getAccounts(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/accounts")
        )
        try transport.register(
            {
                try await server.postAccounts(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/accounts")
        )
        try transport.register(
            {
                try await server.putAccounts(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .put,
            path: server.apiPathComponentsWithServerPrefix("/accounts")
        )
        try transport.register(
            {
                try await server.deleteAccounts(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .delete,
            path: server.apiPathComponentsWithServerPrefix("/accounts")
        )
        try transport.register(
            {
                try await server.getTransactions(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/transactions")
        )
        try transport.register(
            {
                try await server.postTransactions(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .post,
            path: server.apiPathComponentsWithServerPrefix("/transactions")
        )
        try transport.register(
            {
                try await server.putTransactions(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .put,
            path: server.apiPathComponentsWithServerPrefix("/transactions")
        )
        try transport.register(
            {
                try await server.deleteTransactions(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .delete,
            path: server.apiPathComponentsWithServerPrefix("/transactions")
        )
        try transport.register(
            {
                try await server.getTransactionsSync(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/transactions/sync")
        )
        try transport.register(
            {
                try await server.getLiabilities(
                    request: $0,
                    body: $1,
                    metadata: $2
                )
            },
            method: .get,
            path: server.apiPathComponentsWithServerPrefix("/liabilities")
        )
    }
}

fileprivate extension UniversalServer where APIHandler: APIProtocol {
    /// PlaidLinkTokenCreate
    ///
    /// - Remark: HTTP `GET /plaid/link/token/create`.
    /// - Remark: Generated from `#/paths//plaid/link/token/create/get(get-plaid-link-token-create)`.
    func getPlaidLinkTokenCreate(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetPlaidLinkTokenCreate.id,
            using: {
                APIHandler.getPlaidLinkTokenCreate($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.GetPlaidLinkTokenCreate.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetPlaidLinkTokenCreate.Input(headers: headers)
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// PlaidLinkTokenUpdate
    ///
    /// - Remark: HTTP `GET /plaid/link/token/update`.
    /// - Remark: Generated from `#/paths//plaid/link/token/update/get(get-plaid-link-token-update)`.
    func getPlaidLinkTokenUpdate(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetPlaidLinkTokenUpdate.id,
            using: {
                APIHandler.getPlaidLinkTokenUpdate($0)
            },
            deserializer: { request, requestBody, metadata in
                let headers: Operations.GetPlaidLinkTokenUpdate.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetPlaidLinkTokenUpdate.Input(headers: headers)
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// AccountsGet
    ///
    /// Get accounts from server
    ///
    /// - Remark: HTTP `GET /accounts`.
    /// - Remark: Generated from `#/paths//accounts/get(get-accounts)`.
    func getAccounts(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetAccounts.id,
            using: {
                APIHandler.getAccounts($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.GetAccounts.Input.Query = .init(accountId: try converter.getOptionalQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    as: Swift.String.self
                ))
                let headers: Operations.GetAccounts.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetAccounts.Input(
                    query: query,
                    headers: headers
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// AccountsPost
    ///
    /// Post new account to server
    ///
    /// - Remark: HTTP `POST /accounts`.
    /// - Remark: Generated from `#/paths//accounts/post(post-accounts)`.
    func postAccounts(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.PostAccounts.id,
            using: {
                APIHandler.postAccounts($0)
            },
            deserializer: { request, requestBody, metadata in
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.PostAccounts.Input.Body?
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/x-www-form-urlencoded"
                    ]
                )
                switch chosenContentType {
                case "application/x-www-form-urlencoded":
                    body = try await converter.getOptionalRequestBodyAsURLEncodedForm(
                        [Components.Schemas.Account].self,
                        from: requestBody,
                        transforming: { value in
                            .urlEncodedForm(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.PostAccounts.Input(body: body)
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// AccountsPut
    ///
    /// Update existing account on server
    ///
    /// - Remark: HTTP `PUT /accounts`.
    /// - Remark: Generated from `#/paths//accounts/put(put-accounts)`.
    func putAccounts(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.PutAccounts.id,
            using: {
                APIHandler.putAccounts($0)
            },
            deserializer: { request, requestBody, metadata in
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.PutAccounts.Input.Body?
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/json"
                    ]
                )
                switch chosenContentType {
                case "application/json":
                    body = try await converter.getOptionalRequestBodyAsJSON(
                        Components.Schemas.Account.self,
                        from: requestBody,
                        transforming: { value in
                            .json(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.PutAccounts.Input(body: body)
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// AccountsDelete
    ///
    /// Delete account from server
    ///
    /// - Remark: HTTP `DELETE /accounts`.
    /// - Remark: Generated from `#/paths//accounts/delete(delete-accounts)`.
    func deleteAccounts(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.DeleteAccounts.id,
            using: {
                APIHandler.deleteAccounts($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.DeleteAccounts.Input.Query = .init(accountId: try converter.getRequiredQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    as: Swift.String.self
                ))
                return Operations.DeleteAccounts.Input(query: query)
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// TransactionsGet
    ///
    /// - Remark: HTTP `GET /transactions`.
    /// - Remark: Generated from `#/paths//transactions/get(get-transactions)`.
    func getTransactions(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetTransactions.id,
            using: {
                APIHandler.getTransactions($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.GetTransactions.Input.Query = .init(accountId: try converter.getOptionalQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    as: Swift.String.self
                ))
                let headers: Operations.GetTransactions.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetTransactions.Input(
                    query: query,
                    headers: headers
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// TransactionsPost
    ///
    /// - Remark: HTTP `POST /transactions`.
    /// - Remark: Generated from `#/paths//transactions/post(post-transactions)`.
    func postTransactions(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.PostTransactions.id,
            using: {
                APIHandler.postTransactions($0)
            },
            deserializer: { request, requestBody, metadata in
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.PostTransactions.Input.Body?
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/json"
                    ]
                )
                switch chosenContentType {
                case "application/json":
                    body = try await converter.getOptionalRequestBodyAsJSON(
                        [Components.Schemas.Transaction].self,
                        from: requestBody,
                        transforming: { value in
                            .json(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.PostTransactions.Input(body: body)
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// TransactionsPut
    ///
    /// - Remark: HTTP `PUT /transactions`.
    /// - Remark: Generated from `#/paths//transactions/put(put-transactions)`.
    func putTransactions(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.PutTransactions.id,
            using: {
                APIHandler.putTransactions($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.PutTransactions.Input.Query = .init(transactionId: try converter.getOptionalQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "transaction_id",
                    as: Swift.String.self
                ))
                let contentType = converter.extractContentTypeIfPresent(in: request.headerFields)
                let body: Operations.PutTransactions.Input.Body?
                let chosenContentType = try converter.bestContentType(
                    received: contentType,
                    options: [
                        "application/json"
                    ]
                )
                switch chosenContentType {
                case "application/json":
                    body = try await converter.getOptionalRequestBodyAsJSON(
                        Components.Schemas.Transaction.self,
                        from: requestBody,
                        transforming: { value in
                            .json(value)
                        }
                    )
                default:
                    preconditionFailure("bestContentType chose an invalid content type.")
                }
                return Operations.PutTransactions.Input(
                    query: query,
                    body: body
                )
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// TransactionsDelete
    ///
    /// - Remark: HTTP `DELETE /transactions`.
    /// - Remark: Generated from `#/paths//transactions/delete(delete-transactions)`.
    func deleteTransactions(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.DeleteTransactions.id,
            using: {
                APIHandler.deleteTransactions($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.DeleteTransactions.Input.Query = .init(transactionId: try converter.getOptionalQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "transaction_id",
                    as: Swift.String.self
                ))
                return Operations.DeleteTransactions.Input(query: query)
            },
            serializer: { output, request in
                switch output {
                case let .accepted(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 202)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// TransactionsSync
    ///
    /// - Remark: HTTP `GET /transactions/sync`.
    /// - Remark: Generated from `#/paths//transactions/sync/get(get-transactions-sync)`.
    func getTransactionsSync(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetTransactionsSync.id,
            using: {
                APIHandler.getTransactionsSync($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.GetTransactionsSync.Input.Query = .init(cursor: try converter.getOptionalQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    as: Swift.String.self
                ))
                let headers: Operations.GetTransactionsSync.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetTransactionsSync.Input(
                    query: query,
                    headers: headers
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .noContent(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 204)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
    /// LiabilitiesGet
    ///
    /// - Remark: HTTP `GET /liabilities`.
    /// - Remark: Generated from `#/paths//liabilities/get(get-liabilities)`.
    func getLiabilities(
        request: HTTPTypes.HTTPRequest,
        body: OpenAPIRuntime.HTTPBody?,
        metadata: OpenAPIRuntime.ServerRequestMetadata
    ) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        try await handle(
            request: request,
            requestBody: body,
            metadata: metadata,
            forOperation: Operations.GetLiabilities.id,
            using: {
                APIHandler.getLiabilities($0)
            },
            deserializer: { request, requestBody, metadata in
                let query: Operations.GetLiabilities.Input.Query = .init(accountId: try converter.getOptionalQueryItemAsURI(
                    in: request.soar_query,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    as: Swift.String.self
                ))
                let headers: Operations.GetLiabilities.Input.Headers = .init(accept: try converter.extractAcceptHeaderIfPresent(in: request.headerFields))
                return Operations.GetLiabilities.Input(
                    query: query,
                    headers: headers
                )
            },
            serializer: { output, request in
                switch output {
                case let .ok(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 200)
                    suppressMutabilityWarning(&response)
                    let body: OpenAPIRuntime.HTTPBody
                    switch value.body {
                    case let .json(value):
                        try converter.validateAcceptIfPresent(
                            "application/json",
                            in: request.headerFields
                        )
                        body = try converter.setResponseBodyAsJSON(
                            value,
                            headerFields: &response.headerFields,
                            contentType: "application/json; charset=utf-8"
                        )
                    }
                    return (response, body)
                case let .unauthorized(value):
                    suppressUnusedWarning(value)
                    var response = HTTPTypes.HTTPResponse(soar_statusCode: 401)
                    suppressMutabilityWarning(&response)
                    return (response, nil)
                case let .undocumented(statusCode, _):
                    return (.init(soar_statusCode: statusCode), nil)
                }
            }
        )
    }
}
